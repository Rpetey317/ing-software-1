# Clase 1 ~ Introducción a la Ingeniería de Software

## 1.- ¿Qué es el Software?

- _Secuencia de instrucciones que, dada una entrada, genera una salida_

Esta es la definición clásica de software, pero es _un poco_ problemática. No dice nada de la complejidad algorítmica, o la eficiencia con el uso de recursos, o de los usuarios y creadores del programa.

Entre estos, el principal problema es que no hay ninguna mención de las personas involucradas. De hecho, la mayoría de los problemas en la mayoría de los ámbitos de la actividad humana son, precisamente, los otros humanos:

- Para hacer proyectos a escala, se necesita la colaboración de _varias personas_, cada una con sus propias opiniones, objetivos y sentimientos, y tarde o temprano van a surgir problemas en la comunicación.
- Ninguna herramienta puede capturar 1:1 todas las sutilezas de la realidad, siempre hay que tener en cuenta los aspectos que una solución no puede considerar, aún sea para desestimarlos.
- Nuestra creación va a interactuar con otras personas en la realidad, por lo que hay que tener en cuenta la mayor cantidad de posibles puntos de vistas para garantizar el trato digno hacia todos.

Por esto (y otras, _muchas_ razones), necesitamos una nueva definición de software que contemple estos aspectos. Proponemos:

- _Modelo computable de un dominio de problema de la realidad_

Donde:

- _Realidad:_ todo aquello que percibimos, conocemos, y con lo que interactuamos
- _Dominio del problema:_ un recorte de esa realidad
- _Modelo:_ representación de cierta cosa que se quiere modelar
- _Computable:_ que pueda correr en una computadora

El objetivo principal que tiene un informático es que el software que está desarrollando sea el mejor modelo posible del dominio de problema sobre el que se trabaja. Una vez logrado esto, puede buscar mejorar el aspecto de la computabilidad (eficiencia, uso de recursos, etc.).

## 2.- Los programas no son puentes

En las ingenierías más tradicionales, el proceso de creación de un producto terminado (por ejemplo, un puente) se puede resumir en 4 pasos:

1. El ingeniero _piensa_ en una potencial modelo para un problema y empieza a desarrollarla
2. Se produce un _documento técnico_ con las especificaciones del modelo terminado
3. Los obreros _construyen_ el objeto a partir del modelo
4. El cliente recibe un _producto terminado_, terminando así el ciclo

Entonces, uno podría querer encarar la ingeniería de software del mismo modo:

1. El ingeniero piensa en un _modelo de software_
2. Se producen documentos técnicos que detallan _la arquitectura del software_
3. Los programadores _escriben el código_
4. Se le entrega al cliente el _código fuente_ terminado

El problema es que, si se aplica esa metodología en la vida real, es evidente que _no funciona para nada_. Como el contexto del proyecto cambia tan rápido, los programadores terminan pasando la mayoría de su tiempo arreglando los problemas de la arquitectura, y el ingeniero pasa la mayor parte de su tiempo reescribiendo documentos que quedan obsoletos rápidamente. Hay que replantear la manera de desarrollar software, no estamos construyendo edificios.

Como los programadores pasan tanto tiempo arreglando los modelos del ingeniero, sería mejor que _los programadores sean los ingenieros_. Y como el ingeniero produce documentos de diseño, _los documentos son el código_ que producen. Entonces, ¿Quién "construye" el producto a partir de las especificaciones? El siguiente paso es pasarle el código fuente a un compilador o intérprete para que _construya_ la _aplicación terminada_ que va a usar el cliente. Pero esta estructura es análoga a la anterior:

1. Los programadores _piensan_ en potenciales formas de modelar la realidad en software
2. Producen _código fuente_ para el programa concorde al modelo que tienen
3. El compilador o intérprete _construye la aplicación_ a partir del código fuente
4. El cliente recibe la _aplicación terminada_

Este cambio de paradigma es fundamental. Si bien los diagramas de arquitectura de alto nivel son muy útiles en algunos casos, el código no debe ser pensado como _algo a modelar_. El código en sí _es_ el modelo -a veces incluso hasta matemático, otras veces más bien heurístico- de la realidad.

## 3.- ¿Qué es un buen modelo?

Hay 3 ejes que definen un buen modelo:

- **_Funcional:_** Cuán bien el modelo representa el dominio y en qué medida se comporta como lo esperado. Como los modelos científicos buscan representar lo mejor posible fenómenos naturales usando las matemáticas, los modelos de software buscan representar lo mejor posible su dominio con código funcional.
     - Lo ideal es una representación 1:1 con los entes de la realidad
     - Cualquier cosa nueva que aparezca en la realidad, debería aparecer en mi modelo
     - Si _una_ cosa cambia en la realidad, la representación de _esa única cosa_ debería cambiar en mi modelo, ni más ni menos
     - Corresponde a la **parte observacional** del desarrollo.
- **_Descriptivo:_** Qué tan bien describe la realidad, qué tan claro es de entender. El mejor código es el que es tan fácil de leer como lo fue de escribir. Como ya discutimos, un programa no es sólo instrucciones para una computadora. Cosas que resultan indistintas a la máquina (nombre de variables, comentarios, etc.) no son indistintas para los desarrolladores ni los usuarios, por lo que son tan importantes como los aspectos técnicos.
     - Código _claro y legible_, nadie quiere leer 500 líneas de spaghetti
     - Tiene que ser igual de entendible por los demás que por nosotros mismos. Tarde o temprano nueva gente va a tener que trabajar sobre el código
     - Utilizar el _lenguaje propio del negocio_. No todos los involucrados son expertos en la informática, y no todos los informáticos son expertos en el ámbito para el que trabajan. Usar un lenguaje común con el cliente agiliza las comunicaciones
     - Utilizar buenos nombres
     - Parte **artística** del desarrollo
- **_Implementativo:_** Qué tan eficiente es el programa con los recursos. Al fin y al cabo, el fin último del software es correr en una máquina
     - Faltan bullet points

## 4.- No Silver Bullet

As se titula uno de los papers más importantes sobre el desarrollo de software, escrito por Brooks en 1986. En él, Brooks discutía un fenómeno interesante: la electrónica llevaba un tiempo ya haciendo progreso exponencial. Lo que hoy era un procesador de mediana o baja gama, 5 años atrás era considerado tecnología de punta. Y más aún, estaban encaminados a acelerar aún más ese progreso. Sin embargo, del lado del software, si bien habían sucedido grandes avances como el paradigma de objetos, nunca hubo y no parecía venir pronto ningún avance o método que hiciera el desarrollo de software órdenes de magnitud más eficiente como con las computadoras.

Esto se debe a que existen 2 tipos de problemáticas que surgen al desarrollar software:

- _La esencial_, inherente a las características del problema. Mientras va creciendo el problema, la complejidad esencial crece exponencialmente por las interacciones entre las distintas partes del programa.
- _La accidental_, que surge por el hecho de tener que hacer una solución computable. Eventualmente va a haber problemas relacionados a la máquina o las herramientas que usamos para desarrollar el software.

Si bien avances como los lenguajes de programación de alto nivel lograron remover gran parte de la dificultad accidental, la dificultad esencial suponía _de por lejos_ la mayor traba a la hora de desarrollar software, pero no se habían hecho casi avances para lidiar con ella. Las principales dificultades eran:

- **_Complejidad:_** Los programas importantes son construcciones _grandes_ que además _no tienen 2 partes iguales_. Si hubiera partes repetidas, se quitaría una, porque las computadoras no los permiten. Eso hace que cada parte de un programa sea única.
     - Por eso, mientras _más entendible_ sea el software, más fácil es de mantener para nuevas personas.
- **_Conformidad:_** Se modelan cosas arbitrarias, definido totalmente por personas que, muchas veces, demandan cosas irracionales.
     - Por eso, mientras _más representativo_ de la realidad sea, menos problemas van a existir con el cliente.
- **_Variabilidad:_** Se espera que se adapte al cambio. A diferencia de los proyactos físicos, se espera que el software cambie de manera instantánea. Mientras más fác
- **_Invisibilidad:_** El software no es un producto tangible. "Está roto" o "es sólido" son preguntas mucho más abstractas en este contexto.

El nombre del paper alude a la opinión del autor: no existe una única _bala de plata_ capaz de resolver todos esos problemas a la vez. Sin embargo, hay diversos métodos y heurísticas que se pueden adoptar para mitigar lo mayor posible el impacto de cada uno por separado. Lo que diferencia a un buen programador de un _gran_ programador es el saber aplicar eficientemente estos métodos.

## 5.- Pero, ¿Qué es entonces la Ing. de Software?

El término Ing. de Software fue acuñado por la OTAN en una reunión en 1968 donde estaban discutiendo la crisis de software. El principal problema que tenían era que el desarrollo de software era altamente ineficiente y era diícil estimar costos. Otro problema que tenían era que nadie en la reunión era desarrollador de software...

Por muchos años, fue predominante la metodología de _desarrollo en cascada_, que se basaba en dividir el desarrollo en distintas etapas (diseño, desarrollo, validación, release) e ir realizando una por una las tareas respectivas de cada etapa. Fue propuesta por Royce en 1970 (quien dijo, justo debajo del esquema del modelo, que era defectuoso y propenso a fallos). El modelo era defectuoso y propenso a fallos. La división clara de las etapas nunca funcionaba porque siempre surgian problemas o cambios en el proceso que ameritaban re-hacer cosas de pasos anteriores, y el cronograma planeado terminaba estorbando más que ayudando.

## 6.- Conclusiones

- Software == modelo computable de la realidad
- La ingeniería de software es:
     - Distinta a las otras ingenierías
     - Un proceso de aprendizaje
     - Un proceso iterativo e incremental
- El feedback es fundamental para el desarrollo
- Hay que estar preparado para los cambios
